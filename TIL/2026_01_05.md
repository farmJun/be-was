
## DNS란?
DNS는 사람이 읽을 수 있는 도메인 이름(www.naver.com)을 기계가 읽을 수 있는 IP 주소(127.0.0.1)로 변환하는 시스템.
naver.com, google.com -> 도메인 이름(Domain Name)
```
apple@appleui-MacBookPro-21 ~ % ping naver.com

PING naver.com (223.130.192.247): 56 data bytes
```

### 등장 배경
- DNS는 사용자가 기억하기 어려운 IP주소 대신 사람이 쉬운 도메인 이름(문자)으로 인터넷에 접속하기 위해 등장
- 아파넷 시절에는 SRI-NIC에서 HOSTS.TXT 파일을 일괄 관리했지만, 인터넷이 성장하면서 이 중앙 집중식 관리는 한계
- 특정 기관이 모든 호스트 정보를 관리하는 대신, 각 지역이나 조직에서 자체적으로 도메인 정보를 관리(분산 관리)하도록 하여 효율성을 높임


## DNS 동작 과정
1. 웹 브라우저에 www.google.com 입력 -> PC에 저장된 Local DNS(기지국 DNS)에 www.google.com 이라는 호스트 네임에 대한 IP 주소 요청.
   이때, IP 주소가 있을 수도 있고 없을 수도 있음.
   있다 -> 이전에 접속 기록이 있음, Local DNS에 접속 정가 caching되어있어, 바로 IP 주소 응답.
   없다 -> 2번
2. Local DNS는 IP 주소를 찾기 위해 다른 DNS 서버들과 통신(DNS 쿼리) 시작, 먼저 Root DNS
3. Root DNS는 IP 주소가 없으면, 다른 DNS 서버에게 요청하라고 응답
4. Local DNS는 com 도메인을 관리하는 TLD(Top Level Domain) DNS 서버에 요청
5. com 도메인을 관리하는 DNS 서버에도 해당 정보가 없으면, 다른 DNS 서버에게 요청하라고 응답
6. Local DNS 서버는 naver.com DNS(Authoritative) 서버에 요청
7. naver.com DNS(Authoritative) 서버에는 주소가 존재 -> Local DNS에 IP 주소 응답
8. Local DNS는 이를 수신하여, IP 주소로 접속 및 접속 정보 캐싱


## MVC 패턴
관심사 분리가 핵심으로 비즈니스 로직(Model), 화면 표시(View), 사용자 요청 처리(Controller)를 나누어 코드의 재사용성, 확장성을 높이는 디자인패턴


## MVC 패턴 등장 배경
프레젠테이션 로직과 비즈니스 로직이 분리되어 있지 않은 Servlet의 단점을 해결하기 위해 JSP 등장
JSP를 더욱 효과적으로 사용하기 위해 MVC 패턴 적용 시작


## MVC 구성 요소

### Model
데이터 및 비즈니스 로직을 처리하는 구성 요소
다른 구성 요소(View, Controller)와 독립적으로 작동.

### View
사용자에게 정보를 표시하는 부분
View는 Model에게 직접적으로 데이터 요청 X, Controller를 통해 필요한 데이터를 전달 받음.

### Controller
사용자의 요청을 받아 들이는 최초 진입 지점.
Model과 View 사이의 중재자 역할. Model과 View의 직접적인 의존성 제거

## Model 1 Architecture
JSP가 직접 요청을 처리하고, 비즈니스 로직 실행, 응답 생성
JSP 내에서 Java Beans 컴포넌트를 사용하여 데이터를 처리, 비즈니스 로직 구현
- 장점 : 구현 간단 직관, 단순한 웹 어플리케이션에 적합
- 단점 : JSP 내에 프레젠테이션 로직과 비즈니스 로직이 혼재되어 있음. -> 유지보수 및 확장 어려움


## Model 2 Architecture (일반적으로 말하는 MVC 패턴)
컨트롤러 역할을 하는 서블릿이 사용자의 요청을 받음.
모델을 통해 적절한 비즈니스 로직 실행
결과를 뷰에 전달하여 사용자에게 응답
- 장점 : 프레젠테이션 로직과 비즈니스 로직이 분리되어 있어, 유지보수와 확장 용이, 애플리케이션 규모가 커질수록 장점 부각
- 단점 : 모델 1에 비해 초기 구축 복잡.


## JSP MVC 패턴의 한계
- 복잡한 구성
- 뷰와 로직 혼재
- 재사용성, 유연성 제한
- 반복적인 코드 작성
- 요청 처리의 일관성 부족
- 라우팅 및 컨트롤러 관리 복잡


JSP MVC 패턴에서는 클라이언트에서 호출을 할 때마다 Controller(서블릿)들이 구동.
서블릿이 가지는 공통 부분을 매번 작성해야해서 비효율
공통된 부분을 한 번에 처리해주는 존재의 필요성 인식
스프링 MVC에서 Dispatcher Servlet 도입


## HTTP는 무상태이지만, 세션은 있다.
HTTP는 기본적으로 상태를 저장하지 않는다. Stateless
따라서 동일한 연결(같은 브라우저, 같은 사용자) 상에서 연속하여 전달된 두 개의 요청 사이에 연결 고리가 없음 -> "로그인 후 장바구니 이동"처럼 일관된 방식으로 사용자가 페이지와 상호작용하길 원할 때 문제.

하지만, HTTP의 핵심은 무상태이지만, HTTP 쿠키는 상태가 있는 세션을 만들도록 해줌.
헤더의 확장성을 사용하여, 동일한 컨텍스트 혹은 동일한 상태를 공유하기 위해 각각의 요청들에 세션을 만들도록 HTTP 쿠키 추가.


### HTTP 쿠키
HTTP 쿠키는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각
브라우저가 데이터 조각을 저장해 놓았다가, 동일한 서버에 재요청 시 함께 전송
두 요청이 동일한 브라우저에서 들어왔는지 판단할 때 주로 사용 -> 사용자의 로그인 상태 유지

## 쿠키의 목적
- 세션 관리 : 서버에 저장해야 할 로그인 등의 정보
- 개인화 : 사용자 선호, 테마 세팅
- 트래킹 : 사용자 행동을 기록하고 분석


과거엔 클라이언트 측에 정보를 저장할 때 쿠키를 주로 사용.
클라이언트 측에 데이터를 저장할 수 있는 유일한 방법이었을 땐 타당한 방법
하지만 지금은 권장되지 않음.

모든 요청마다 쿠키가 함께 전송되어 성능 저하의 원인

## 쿠키 만들기
HTTP 요청을 수신할 때, 서버는 응답과 함께 "Set-Cookie" 헤더를 전송
쿠키는 보통 브라우저에 의해 저장.
이후 같은 서버에 의해 만들어진 요청의 HTTP "Cookie" 헤더에 포함하여 전송

### Set-Cookie 및 Cookie 헤더

```
Set-Cookie: <cookie-name>=<cookie-value>

HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

```
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```


## 쿠키의 라이프타임
세션 쿠키(Expires, Max-Age 속성이 없는 쿠키) : 현재 세션이 끝날 때 삭제.
영속적인 쿠키 : Expires 속성에 명시된 날짜에 삭제, Max-Age 속성에 명시된 기간 이후 삭제
만료 시점의 시간과 날짜는 서버의 시간이 아니라 쿠키가 저장되는 클라이언트 시간 기준
```
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT
```
